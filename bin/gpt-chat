#!/bin/bash
#
# GPT-Chat (c) 2023 Normen Hansen
# - needs jq
# - optionally uses rlwrap
#
set -e

# default path to cloud storage
cloud_path="$HOME/Library/Mobile Documents/com~apple~CloudDocs/GPT"
if [ ! -d "$cloud_path" ]; then
  cloud_path="$HOME/.config/gpt-chat"
fi

if ! which jq>/dev/null; then
  echo "Error: jq command not found, please install with 'sudo apt install jq'"
  exit 1
fi

load_config(){
  create_folders
  create_config
  api_key=$(jq -r '.api_key' "$cloud_path/config.json")
  current_conversation=$(jq -r '.current_conversation' "$cloud_path/config.json")
  system_message=$(jq -r '.system_message' "$cloud_path/config.json")
  model_name=$(jq -r '.model_name' "$cloud_path/config.json")
  max_tokens=$(jq -r '.max_tokens' "$cloud_path/config.json")
  temperature=$(jq -r '.temperature' "$cloud_path/config.json")
  loop_question=$(jq -r '.loop_question' "$cloud_path/config.json")
  intro_question=$(jq -r '.intro_question' "$cloud_path/config.json")
}

set_config(){
  create_folders
  create_config
  jq --compact-output --arg name "$1" --arg value "$2" '.[$name] = $value' \
    "$cloud_path/config.json" > "$cloud_path/config.new"
  mv "$cloud_path/config.new" "$cloud_path/config.json"
}

set_config_number(){
  create_folders
  create_config
  eval $1="$2"
  jq --compact-output --arg name "$1" --argjson value $2 '.[$name] = $value' \
    "$cloud_path/config.json" > "$cloud_path/config.new"
  mv "$cloud_path/config.new" "$cloud_path/config.json"
}

create_folders(){
  if [ ! -d "$cloud_path" ]; then
    cloud_path="$(mktemp -d)"
    echo "Creating: $cloud_path"
    #trap 'err=$?; echo >&2 "Exiting on error $err"; exit $err' EXIT
    trap "rm -rf $cloud_path; echo 'Deleted temp folder'" EXIT
  fi
  if [ ! -d "$cloud_path/conversation" ]; then
    mkdir -p "$cloud_path/conversation"
  fi
}

create_config(){
  if [ ! -f "$cloud_path/config.json" ]; then
    echo "Creating: $cloud_path/config.json"
    echo '{
      "model_name":"gpt-3.5-turbo",
      "max_tokens":1024,
      "temperature":1,
      "system_message": "Du bist eine freundliche KI die stets mit akkuraten Informationen zur Hilfe steht.",
      "intro_question":"Wie kann ich helfen?",
      "loop_question":"Noch etwas?",
      "current_conversation": "conversation"
    }' > "$cloud_path/config.json"
    api_key=$(cat ~/.config/openaiapirc | sed -n -e 's/^secret_key *= *\(.*\)$/\1/p')
    if [ "$api_key" == "" ];then
      echo "Error: no API key found at ~/.config/openapirc"
      exit 1
    fi
    set_config api_key "$api_key"
  fi
}

create_conversation(){
  if [ ! -f "$cloud_path/conversation/$current_conversation.json" ]; then
    jq --null-input --compact-output\
      --arg model_name "$model_name"\
      --argjson max_tokens "$max_tokens"\
      --argjson temperature "$temperature"\
      --arg system_message "$system_message" '{
          "model": $model_name,
          "max_tokens": $max_tokens,
          "temperature": $temperature,
          "messages": [
          { "role": "system",
            "content": $system_message }
            ]
          }' > "$cloud_path/conversation/$current_conversation.json"
  fi
}

get_gpt_answer(){
  create_conversation
  jq --compact-output --arg c "$user_input" '.messages = .messages + [{"role": "user", "content": $c }]' \
    "$cloud_path/conversation/$current_conversation.json" \
    > "$cloud_path/conversation/$current_conversation.new"
  mv "$cloud_path/conversation/$current_conversation.new" "$cloud_path/conversation/$current_conversation.json"
  chatgpt_output=$(cat "$cloud_path/conversation/$current_conversation.json" |\
    curl -s https://api.openai.com/v1/chat/completions \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer ${api_key}" \
      -d @- |\
      jq -r '.choices[0].message.content')
  jq --compact-output --arg c "$chatgpt_output" '.messages = .messages + [{"role": "assistant", "content": $c }]' \
    "$cloud_path/conversation/$current_conversation.json" \
    > "$cloud_path/conversation/$current_conversation.new"
  mv "$cloud_path/conversation/$current_conversation.new" "$cloud_path/conversation/$current_conversation.json"
  echo "$chatgpt_output"
}

read_input(){
  read -r -p "Mensch: "
  user_input=$REPLY
}

read_stdin(){
  load_config
  user_input=$(cat)
  get_gpt_answer
}

do_loop(){
  user_input="-"
  load_config
  echo ""
  echo "Path: $cloud_path"
  echo ""
  echo "Conversation: $current_conversation"
  read_input
  while [ ! "$user_input" == "" ]
  do
    printf "KI: "
    get_gpt_answer
    read_input
  done
}

while getopts ":hxPp:c:m:s:t:T:" option; do
  case $option in
    h) # display help
      echo "GPT Chat"
      echo ""
      echo "Communicate with GPT using the command line, conversations are kept in cloud storage or local folder."
      echo ""
      echo "iCloud storage folder 'GPT' on Mac, otherwise if a folder at ~/.config/gpt-chat exists that is used, else a temp folder is created"
      echo ""
      echo "-h: display this help"
      echo ""
      echo "-x: temporary storage only (set before other options)"
      echo "-p <cloud_path>: set path for storage (set before other options)"
      echo ""
      echo "-P pipe in data to conversation (multiline text)"
      echo ""
      echo "-c <conversation>: set conversation name"
      echo "-m <model_name>: set model name"
      echo "-t <temperature>: set temperature"
      echo "-T <max_tokens>: set max tokens returned"
      echo "-s <system_message>: set system message (prompt)"
      echo ""
      echo "Needs jq and rlwrap"
      exit;;
    x) cloud_path="";;
    p) cloud_path="$OPTARG"
      if [ ! -d "$cloud_path" ]; then
        mkdir -p "$cloud_path"
      fi;;
    c) set_config "current_conversation" "$OPTARG";;
    m) set_config "model_name" "$OPTARG";;
    s) set_config "system_message" "$OPTARG";;
    t) set_config_number "temperature" $OPTARG;;
    T) set_config_number "max_tokens" $OPTARG;;
    P) read_stdin
      exit;;
    \?)
      echo "Error: Invalid option, use -h for help."
      exit;;
  esac
done
shift $((OPTIND-1))

create_folders
create_config
if [ ! -z $RLWRAP_RUNNING ]; then
  do_loop
else
  # start using rlwrap if available
  if which rlwrap>/dev/null; then
    RLWRAP_RUNNING=1 rlwrap -pgreen -m -M .txt -r -O "Mensch:" $0 -p "$cloud_path"
  else
    echo "Warning: rlwrap not found, install with 'sudo apt install rlwrap'"
    do_loop
  fi
fi

